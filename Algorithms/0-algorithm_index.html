<html> <head>
<title>Galant Algorithm Examples</title>
</head>

<body text=black bgcolor=white>
<h2>Galant Algorithm Examples</h2>


<h3>Unweighted Graph Algorithms</h3>

<ul>
<br><hr>
<li><b><a href="bfs.alg">bfs.alg</a></b> 
<br>
An Animation of breadth-first search. Undirected edges are regarded as
being directed both ways.
<br>
<br><hr>
<li><b><a href="dfs.alg">dfs.alg</a></b> 
<br>
Animates depth-first search of a graph, directed or undirected; in the
undirected case, it behaves as if edges were directed in both directions.
<br>
<br><hr>
<li><b><a href="interactive_dfs.alg">interactive_dfs.alg</a></b> 
<br>
Animates depth-first search of a directed graph
only; directedness is forced at the beginning of the algorithm; allows
user to specify start node and next node to visit in each iteration of the
outer loop.
<br>
<br><hr>
<li><b><a href="dfs_scc.alg">dfs_scc.alg</a></b> 
  <br>
  Same as interactive_dfs, but adds the reverse depth-first search that
  computes strongly connected components in topological order; can also be
  used to illustrate topological sort of a directed acyclic graph (each
  vertex is a singleton strongly connected component).
<br><br>
</ul>

<h3>Weighted Graph Algorithms</h3>

<ul>
<li><b><a href="dijkstra.alg">dijkstra.alg</a></b> 
An animation of Dijkstra's shortest path algorithm. Interprets
undirected edges as going in both directions.
<br>
<br><hr>
<li><b><a href="euclidian.alg">euclidian.alg</a></b> 
<br>
An animation of Dijkstra's shortest path algorithm. Interprets
undirected edges as going in both directions.
Unlike dijkstra.alg, the edge weights are set initially by the
algorithm, based on Euclidian distances between nodes.
<br>
<br><hr>
<li><b><a href="sheehy_sp.alg">sheehy_sp.alg</a></b>
Implementation of Dijkstra's shortest path algorithm. Interprets
undirected edges as going in both directions.

This version, based on an idea by Don Sheehy, puts edges rather than
vertices on a priority queue.
Because the distance from start vertex to the other endpoint of the edge
does not change, there is no need for a decreaseKey() operation.

Two features of this implementation are
<ul>
<li>lazy deletion: edges to vertices already in the tree are ignored when
removed from the queue</li>
<li>a dummy edge from the start vertex to itself; it will be the first edge removed</li>
</ul>
<br>
<br><hr>
<br>
<li><b><a href="kruskal.alg">kruskal.alg</a></b> 
<br>
animation of Kruskal's MST algorithm; edges are sorted at the beginning and
the algorithm continues until all edges have been considered
<br><hr>
<br>
<b><a href="kruskal_pq.alg">kruskal_pq.alg</a></b><br>
An animation of Kruskal's MST algorithm; edges are put on a priority queue at
the beginning and the algorithm stops when a tree has been formed; assumes
that the graph is connected
<br>
<br><hr>
<li><b><a href="prim.alg">prim.alg</a></b> 
<br>
animation of Prim's MST algorithm; essentially the same as dijkstra.alg,
except that graph is made undirected at the beginning and the weight of the
connecting edge
rather than distance from the start vertex is used as priority
<br>
<br><hr>
<li><b><a href="boruvka.alg">boruvka.alg</a></b> 
An animation of Boruvka's MST algorithm; designed
to showcase some of the newer Galant facilities.<br>
Among these are:<br>
- hideLabel() and showLabel() for graph elements to identify components<br>
- hide() and show() for graph elements to show only the edges that are relevant<br>
- color() and uncolor() for graph elements using predefined colors
<br>
<br><hr>
</ul>

<h3>Sorting Algorithms</h3>

All of these assume that the input graph has no edges and that the node
weights represent the keys of elements to be sorted.

<ul>
<li><b><a href="bubble_sort.alg">bubble_sort.alg</a></b> 
An animation of bubble sort.
This is the simplest version of bubble sort; makes a pass over the whole
list each iteration
<br>
<br><hr>
<li><b><a href="insertion_sort.alg">insertion_sort.alg</a></b> 
An animation of insertion sort.
The already sorted part of the array is marked. The element to be
inserted moves along the array -- the element to which it is compared at
each step is highlighted.
<br>
<br><hr>
<li><b><a href="quicksort.alg">quicksort.alg</a></b> 

An animation of Quicksort<br>
<em>authors: Hayden Fuss, Solomon Yeh, Jordan Connor</em><br>
<em>CSC 316, Data Structures, Spring 2015, Project</em><br>
This Quicksort implementation chooses the median index of the list
as the pivot, and can handle an arbitrary sized array, but
visual fidelity for large arrays requires extra vertical space
<br>
<br>
</ul>

<h3>Miscellaneous Algorithms</h3>

<ul>
<li><b><a href="binary_tree.alg">binary_tree.alg</a></b> 
<br>
Draws a binary tree that fits into current graph window. First queries the
user about the tree height.
<br>
<br><hr>
<li><b><a href="grid.alg">grid.alg</a></b> 
<br>
Creates a grid graph with dimensions supplied by user
<br>
<br><hr>
<li><b><a href="strip_attributes.alg">strip_attributes.alg</a></b> 
<br>
Strips out unneccessary attributes from graphs
where weights, labels and colors were created inadvertently
during editing.
<br>
</ul>

<hr>
<address>
<a href="http://people.engr.ncsu.edu/mfms/">
Matthias F. (Matt) Stallmann
</a>

Created: 
Fri Nov 4 13:15:28 EDT 2016
</address>
