Animation programmers can write algorithms in notation that resembles
textbook pseudocode
in files that have a \Code{.alg} extension.
The animation examples have used procedural syntax for function calls, as in, for example,
\Code{setWeight(v, 0)}.
Java (object oriented) syntax can also be used: \Code{v.setWeight(0)}.
A key advantage of Galant is that a seasoned Java programmer can
not only use the Java syntax but can also augment Galant algorithms with
arbitrary Java classes defined externally, using \Code{import} statements.
All Galant code is effectively Java, either natively, or via macro
preprocessing.

Some Java constructs have no equivalent procedural syntax. Most notably
\Code{\emph{sOne}.equals(\emph{sTwo})}, where \emph{sOne} and
\emph{sTwo} are strings (of type \Code{String}) is the only means of
equality comparison for strings. Equality of numbers is tested using the
\Code{==} operator.
To compare strings lexicographically you have to use
\Code{\emph{sOne}.compareTo(\emph{sTwo})}, which returns a positive
number, negative number, or 0 depending on whether \emph{sOne}
lexicographically follows,
precedes or is equal to \emph{sTwo}, respectively.

Descriptions in this document give the most natural and most common
constructs for procedures and functions, usually procedural rather
than object-oriented.
A perusal of the file \Code{Algorithm.java} in directory\\ 
\hspace*{1em}\Code{src/edu/ncsu/csc/Galant/algorithm}\\
shows the animator the variety of
synonyms for these constructs
as well as functions not described here. For the interested Java programmer,
object-oriented syntax appears as a call in the body of the corresponding
function/procedure. For example,
\begin{verbatim}
  public void mark(Node n) throws Terminate, GalantException {
    checkGraphElement(n);
    n.mark();
  }
\end{verbatim}
shows how the procedural version of \Code{mark} translates to the
corresponding \Code{Node} method. Here, \Code{checkGraphElement(n)} throws an
exception with a meaningful error message if \Code{n} is \Code{null}.
The \Code{Terminate} exception results when the user chooses to exit the
animation (not really an exception so much as an alert to the animation
program).

We encourage an animator to browse the example animations in subdirectories
\Code{Algorithm}, \Code{Test} and in the subdirectories of \Code{Research}.

The text panel provides a crude editor for algorithms (as well as GraphML
descriptions of graphs);
its limited capabilities make it useful primarily for fine tuning and error correction.
The animator should use a program editor such as \Code{Emacs} or
\Code{Notepad++} (in Java mode) to edit algorithms offline,
not a major inconvenience -- it is easy to reload algorithms when they are modified
without exiting Galant.
The Galant editor is, however, useful in that it provides syntax highlighting of Galant
functions and macros.

The source code for an algorithm begins with any number (including none)
of global variable declarations and function definitions.
The animator can import code from other sources using appropriate
\Code{import} statements; these must occur at the very beginning.
The code for the algorithm itself follows, starting with the keyword
\Code{algorithm}.
A \emph{code block}
is a sequence of statements, each terminated by a semicolon, just as in
Java.
An animation program has the form
\begin{quote}
  \emph{global variable declarations}\\
  \\
  \emph{function definitions}\\
  \\
  \Code{algorithm \{}\\
  \hspace*{2em}\emph{code block}\\
  \Code{\}}
\end{quote}

Declarations of global variables are also like those of Java:\\
\hspace*{1em}\Code{\emph{type} \emph{variable\_name};}\\
to declare a variable or\\
\hspace*{1em}\Code{\emph{type} [] \emph{variable\_name};}\\
to declare an array of the given type.
All variables must be initialized either within a function definition or
in the algorithm.
Unlike Java variables, they cannot be initialized in the statement that
declares them.\footnote{This restriction applies to global variables
  only. Variables local to function definitions or to the algorithm can be
  initialized in-line, just as in Java.
}
The Java incantation\\
\hspace*{1em}\Code{\emph{type} \emph{variable\_name}
= new \emph{type}[\emph{size}]}\\
is used to initialize an array with \emph{size} elements initialized to \Code{null}
or 0. Arrays use 0-based indexing: the largest index is $\mathit{size} -
1$. The \emph{type} prefix is omitted if the array has been declared
globally.
For example, you could have a global declaration\\
\hspace*{1em}\Code{String [] alpha;}\\
and then, within a function or the algorithm body,\\
\hspace*{1em}\Code{alpha = new String[10]}.
The array \Code{alpha} would then contain 10 null strings (not to be confused
with \Code{""})\footnote{
  For example, \Code{alpha[2].equals("")} would cause a null pointer
  exception but not if you did \Code{alpha[2] = "abc"} first -- then it would
  simply return \Code{false}.
}
indexed from 0 through 9.
\label{page:arrays}

Detailed
information about function declarations is in Section~\ref{sec:functions}
below.

Central to the Galant API is the \Code{Graph} object: currently all other
parts of the API refer to it.
The components of a graph are declared to be of type \Code{Node} or
\Code{Edge} and can be accessed/modified via a variety of
functions/methods.
When an observer or explorer interacts with the animation they move either
forward or backward one step at a time.
All aspects of the graph API therefore refer to the current \emph{state of
  the graph}, the set of states behaving as a stack.
API calls that change the state of a node or an edge automatically
generate a next step,
but the programmer can override this using a \Code{beginStep()} and
\Code{endStep()} pair. For example, the beginning of our implementation of
Dijkstra's algorithm looks like

\begin{center}
\begin{minipage}{0.5\textwidth}
\begin{verbatim}
beginStep();
for_nodes(node) {
    setWeight(node, INFINITY);
    insert(node, pq);
}
endStep();
\end{verbatim}
\end{minipage}
\end{center}

Without the \Code{beginStep}/\Code{endStep}
override, this initialization would require the observer to click
through multiple steps (one for each node) before getting to the interesting
part of the animation.
For convenience the function \Code{step()} is a synonym for \Code{endStep();~beginStep()}.
If a step takes longer than \Timeout\ seconds, the program is terminated
under the presumption that there may be an infinite loop.

\input{Y_graph_functions}

\input{Y_utility_functions}

Functions and macros for the graph as a whole are shown in Table~\ref{tab:graph_functions}, while Table~\ref{tab:utility_functions} lists some algorithm functions not related to any aspect of a graph.

\emph{\textbf{Note:} The functions/methods provided by Galant may have multiple synonyms for
convenience and backward compatibility. A full list of methods and functions
is given in \Code{Algorithm.java} in the subdirectory
\Code{src/edu/ncsu/csc/Galant/algorithm}.}

The nodes and edges, of type \Code{Node} and \Code{Edge}, respectively,
are subtypes/extensions of \Code{GraphElement}.
Arbitrary attributes can be assigned to each graph element. In the GraphML file
these show up as, for example,\\
\hspace*{3em}
\Code{
$<$node \emph{attribute\_1}="\emph{value\_1}" ... \emph{attribute\_k}="\emph{value\_k}" /$>$
}

Each node and edge has a unique integer id.
The id's are assigned consecutively as nodes/edges are created;
they may not be altered.
The id of a node or edge $x$ can be accessed via the function call \Code{id($x$)}.
Often, as is the case with the depth-first search algorithm, it makes sense to use
arrays indexed by node or edge id's.
Since graphs may be generated externally and/or have undergone deletions of nodes or
edges, the id's are not always contiguous.\footnote{
  The edges in GraphML files are not required to have id's. If they have
  none, id's are assigned as the file is parsed. These assigned id's are not
  preserved when the graph (GraphML file) is saved.
}
The functions \Code{nodeIds()} and \Code{edgeIds()} return the size of an array
large enough to accommodate the appropriate id's as indexes. So code such as

\begin{minipage}{0.8\textwidth}
\begin{verbatim}
        Integer myArray[] = new Integer[nodeIds()];
        for_nodes(v) { myArray[id(v)] = 1; }
\end{verbatim}
\end{minipage}

is immune to array out of bounds errors.

\subsection{Node and edge attributes and methods} \label{sec:nodes_and_edges}

Nodes and edges have `getters' and `setters' for
a variety of attributes, i.e.,
\\
\Code{set}$a$\Code{($\langle a's$ type$\rangle$ x)}
\\
and
\\
$\langle a's$ type$\rangle$ \Code{get}$a$\Code{()},
where $a$ is the name of an attribute such as
\Code{Color},
\Code{Label} or \Code{Weight}.
A more convenient way to access these standard attributes omits the prefix \Code{get}
and uses procedural syntax:
\Code{color(}$x$\Code{)} is a synonym for $x$\Code{.getColor()}, for example.
Procedural syntax for the setters is also available:
\Code{setColor(}$x$,$c$\Code{)} is a synonym for $x$.\Code{setColor(}$c$\Code{)}.
In the special cases of color and label it is possible to omit the \Code{set}
(since it reads naturally):
\Code{color($x$,$c$)} instead of
\Code{setColor($x$,$c$)};
and
\Code{label($x$,$c$)} instead of
\Code{setLabel($x$,$c$)}.

In the subsections below we discuss attributes in more detail, using the
categories articulated in the GDR paper -- (earlier) citation in the technical
report.

\subsubsection{Logical attributes: functions and macros}

\textbf{Nodes.} From a node's point of view we would like information about
the adjacent nodes and incident edges.
Macros that hide some Java syntax and extra function calls are provided for
that purpose.
The macros (which are borrowed from their equivalents in GDR) are:

\begin{itemize}

\item
\Code{for\_adjacent($v, e, w$) \{ \emph{code block} \}}\\
executes the statements in the code block for each edge incident on node $v$.
The statements can refer to $v$, or $e$, the current incident edge,
or $w$, the other endpoint of $e$.
The macro assumes that $v$ has already been declared as \Code{Node}
but it declares $e$ as \Code{Edge} and $w$ as \Code{Node} automatically.

\item
\Code{for\_outgoing($v, e, w$) \{ \emph{code block} \}}\\
behaves like \Code{for\_adjacent} except that, when the graph is directed,
it iterates only over the edges whose source is $v$ (it still iterates over all the edges when the graph is undirected). 

\item
\Code{for\_incoming($v, e, w$) \{ \emph{code block} \}}\\
behaves like \Code{for\_adjacent} except that, when the graph is directed,
it iterates only over the edges whose target (destination) is $v$ (it still iterates over all the edges when the graph is undirected). 

\end{itemize}

The actual API methods hiding behind these macros are (these are Node methods):

\begin{itemize}
\item
\Code{EdgeList~edges($v$)} returns a list of all edges
incident to $v$, both incoming and outgoing.
\item
\Code{EdgeList~outgoingEdges($v$)} returns a list of edges
directed away from $v$ (all incident edges if the graph is undirected).
\item
\Code{EdgeList~incomingEdges($v$)} returns a list of edges
directed toward $v$ (all incident edges if the graph is undirected).
\item
\Code{Node~otherEnd($e$, $v$)} returns the endpoint, other than $v$, of $e$.
\end{itemize}

The following are node functions with procedural syntax.

\begin{itemize}
\item \Code{degree(v)}, \Code{indegree(v)} and \Code{outdegree(v)} return the appropriate
integers.
\item \Code{otherEnd(v, e)}, where \Code{v} is a node and \Code{e} is an edge
returns node \Code{w} such that \Code{e} connects \Code{v} and \Code{w};
the programmer can also say \Code{otherEnd(e, v)} in case she forgets the order
of the arguments.
\item \Code{neighbors(v)} returns a list of the nodes adjacent to node \Code{v}.
\end{itemize}

\bigskip
\textbf{Edges.}
The logical attributes of an edge $e$ are its source and target (destination)
accessed using \Code{source($e$)} and \Code{target($e$)}, respectively.

\bigskip
\textbf{Graph Elements.}
Nodes and edges both have a mechanism for setting (and getting)
arbitrary attributes of type Integer, String, and Double.
the relevant functions are listed below.
Note that the type can be implicit for the setters -- the compiler can figure
that out, but needs to be explicit for the getters -- in Java, two methods
that differ only in their return type are indistinguishable.
In each case $g$ stands for a graph element (node or edge).
\begin{itemize}
  \item \Code{set($g$, String \emph{attribute}, $\langle \mathit{type} \rangle$ \emph{value})},
    where \emph{type} can be \Code{String}, \Code{Boolean}, \Code{Integer},
    or \Code{Double}.
  \item \Code{set($g$, String \emph{attribute})}; the attribute is assumed to
    be Boolean, the value is set to \Code{true}.
  \item \Code{String getString($g$, String \emph{attribute})}
  \item \Code{Boolean getBoolean($g$, String \emph{attribute})}
    \item \Code{Boolean is($g$, String \emph{attribute})}, a synonym for
      \Code{getBoolean} 
  \item \Code{Integer getInteger($g$, String \emph{attribute})}
  \item \Code{Double getDouble($g$, String \emph{attribute})}
\end{itemize}
An object oriented syntax can also be used -- this is especially natural in
case of \Code{is}, as in \Code{v.is("inTree")} -- see \Code{boruvka.alg} in the
\Code{Algorithms} directory.

Arbitrary attributes
are useful when an algorithm requires additional information to be
associated with nodes and/or edges.
The user-defined attributes may differ from one node or edge to the next.
For example, some nodes may have a \Code{depth} attribute while others do not.

\textbf{Note:} \emph{Attributes retain their types throughout algorithm
  execution but Galant does not attempt to guess the type of an attribute
  when reading a graph from a file.}
For example, suppose an algorithm does \Code{set(v, "pre", 5)}.
To read the value of attribute \Code{pre} for node \Code{v} the algorithm
will have to use \Code{getInteger(v, "pre")} (or one of its synonyms) --
\Code{getDouble(v, "pre")} or \Code{getString(v, "pre")} will return
\Code{null}. 
However, suppose the user exports the graph to a file \Code{mine.graphml}
after setting the attribute.
The GraphML representation for node \Code{v} will have \Code{pre="5"},
but when Galant reads \Code{mine.graphml}, the attribute \Code{pre}, and any
other user-defined attribute, will be treated as a string attribute. So  
\Code{getInteger(v, "pre")} will return \Code{null} whereas
\Code{getString(v, "pre")} will return the string \Code{"5"}.
This is not a problem unless the user wants to save the state of an algorithm
execution midstream \emph{and then use it as a starting point}.
The only workaround is for an animation program to do its own parsing, using
the utility functions \Code{integer} and \Code{real} -- see
Table~\ref{tab:utility_functions}.

\subsubsection{Geometric attributes}

Currently, the only geometric attributes are the positions of the
nodes. 
Unlike GDR, the edges in Galant
are all straight lines and the positions of their labels are fixed.
The relevant functions are
\Code{int~getX(Node $v$)}, \Code{int~getY(Node $v$)}
and \Code{Point~getPosition(Node $v$)}
for the getters. The Java type/class \Code{Point} has fields \Code{x} and
\Code{y} that can be retrieved using \Code{$p$.x} and \Code{$p$.y}, where $p$
is a \Code{Point}. To set a position, use\\
\hspace*{2em}\Code{setPosition(Node $v$, Point $p$)}\\
or\\
\hspace*{2em}\Code{setPosition(Node $v$, int $x$, int $y$)}.\\
Once a node has an established position, it is possible to change
one coordinate at a time using \Code{setX(Node $v$, int $x$)} or
\Code{setY(Node $v$, int $y$)}.

The user is allowed to move nodes during algorithm execution
and the resulting positions persist after execution terminates
(other attributes do not).
Node position is the only attribute that can be "edited" by the user
at runtime.
For some animations, however, such as sorting,
the animation itself needs to move
nodes.
To avoid potential conflicts between position changes inflicted by the user
and those desired by the animation,
the function \Code{movesNodes()}, called at the beginning of an algorithm,
will keep the user from moving nodes (mouse actions on the graph panel have
no effect).

\subsubsection{Display attributes} \label{sec:display_attributes}

Each node and edge has
both a (double) weight and a label.
The weight
is also a logical
attribute in that
it is used implicitly as a
key for
sorting and priority queues.
The label is simply text and may be interpreted however the programmer
chooses.
The conversion functions \Code{integer(String)}
and \Code{real(String)}
-- see Table~\ref{tab:utility_functions}
-- provide a convenient mechanism for treating labels as objects of class
\Code{Integer} or \Code{Double}, respectively.
The second argument of \Code{label}
is not the expected \Code{String}
but \Code{Object};
any type of object that has a Java \Code{toString} method will work
-- numbers have to be of type \Code{Integer} or \Code{Double}
rather than \Code{int} or \Code{double} since the latter are not objects
in Java.\footnote{
  Galant functions return objects, \Code{Integer} or \Code{Double}, when
  return values are numbers for this reason.
}
Thus, conversion between string labels and numbers works both ways.

The \Code{display} and \Code{print} functions also take arbitrarily many objects as
arguments. So \Code{display($g$)} and \Code{print($g$)}, where $g$ is a node
or edge will print information about the attributes of $g$ (as a list in
square brackets). Often, you only want to display/print the id of a node or
the source and target of an edge. The appropriate incantations for
\Code{display} are \Code{display(id($g$))} and \Code{display(string($g$))},
respectively. The \Code{string} function is designed specifically for this
purpose and applies only to edges.
Because these functions allow more than one argument, you can say, for
example,\\
\hspace*{3em}\Code{display("node = ", id(node), " edge = ", edge)}\\
instead of the more awkward\\
\hspace*{3em}\Code{display("node = " + id(node) + " edge = " + edge)}\\
demanded by Java string syntax.

In order to make the display of weights more attractive, weights that happen
to be integers are shown without the decimal point and at most two positions
to the right of the decimal point are shown.

Aside from the setters and getters: \Code{setWeight(GraphElement $g$, double $wt$)},
\mbox{\Code{Double getWeight($g$)}}, \Code{label($g$, Object $o$)}
and \mbox{\Code{String label($g$)}}, the programmer can also
manipulate and test for the absence of weights/labels using
\Code{clearWeight($g$)} and \Code{Boolean~hasWeight($g$)},
and the corresponding methods for labels.
It is also possible to remove an arbitrary attribute $a$ using
\Code{clear($g$, String $a$)}, but there is not yet a \Code{has} function for
arbitrary attributes.\footnote{Semantic details, such as whether to implement
  \Code{hasString($g$, $a$)}, \Code{hasInteger($g$, $a$)}, etc., and/or to use
  \Code{has($g$, $a$)} to check whether the attribute exists in any form need
    to be worked out.
}
You have to test whether the getter returns \Code{null}.

Nodes can either be plain, highlighted (selected), marked (visited) or both highlighted and
marked.
Being highlighted alters the
the boundary (color and thickness) of a node (thickness is controlled by user
preference),
while being marked affects the fill color.
Edges can be plain or selected, with thickness and color modified in the
latter case.

The relevant methods are
(here $g$ refers to an object of type \Code{GraphElement}, a \Code{Node} or
an \Code{Edge}):
\begin{itemize}
\item \Code{highlight($g$)}, \Code{unhighlight($g$)}
  and \Code{Boolean~highlighted($g$)}
\item correspondingly, \Code{select($g$)}, \Code{deselect($g$)},
and \Code{Boolean~selected($g$)}
\item \Code{mark(Node $v$)}, \Code{unmark(Node $v$)}
  and \Code{Boolean~marked(Node $v$)}
\end{itemize}

\begin{table}
  \centering
  \begin{tabular}{{| l @{~=~} l |}}
    \hline
    \texttt{RED} & \texttt{"\#ff0000"} \\ \hline
    \texttt{BLUE} & \texttt{"\#00ff00"} \\ \hline
    \texttt{GREEN} & \texttt{"\#0000ff"} \\ \hline
    \texttt{YELLOW} & \texttt{"\#ffff00"} \\ \hline
    \texttt{MAGENTA} & \texttt{"\#ff00ff" } \\ \hline
    \texttt{CYAN} & \texttt{"\#00ffff"} \\ \hline
    \texttt{TEAL} & \texttt{"\#009999"} \\ \hline
    \texttt{VIOLET} & \texttt{"\#9900cc"} \\ \hline
    \texttt{ORANGE} & \texttt{"\#ff8000"} \\ \hline
    \texttt{GRAY} & \texttt{"\#808080"} \\ \hline
    \texttt{BLACK} & \texttt{"\#000000"} \\ \hline
    \texttt{WHITE} & \texttt{"\#ffffff"} \\ \hline
  \end{tabular}
  \caption{Predefined color constants.}
  \label{tab:colors}
\end{table}

Although the specific colors for displaying the outlines of nodes
or the lines representing edges are
predetermined for plain
and highlighted nodes/edges,
the animation implementation can modify colors explicitly,
thus allowing for many different kinds of highlighting.
Use the \Code{color($g$)} (getter), \Code{color($g$, $c$)} (setter)
and \Code{uncolor($g$)} functions, where $g$ is a
node/edge and $c$ a color string
in the RGB format \texttt{\#RRGGBB}; for example,
the string \texttt{\#0000ff} is blue.
Galant defines several color constants for convenience -- 
these are listed in Table~\ref{tab:colors} -- so one can say, e.g.,
\Code{color($g$,TEAL)} instead of \Code{color($g$,"\#009999")}.

Note: In the graph display \emph{highlighting takes precedence over color};
if a node is highlighted, its color is ignored and the default highlight
color is used.

Special handling is required when one of the native Galant attributes
is nonexistent or has a
\Code{null} value -- these two are equivalent.
When displayed in the graph window, nonexistent labels and weights simply do
not show up while nonexistent colors are rendered as thin black lines
(thickness determined by user preference).
In an animation program, however, nonexistent attributes are handled
differently.
\begin{itemize}
\item \Code{color($g$)} returns null as expected
\item all functions returning Boolean values, such as \Code{highlighted($g$)},
  \Code{marked(Node $v$)} and those for attributes defined by the animator, return
  \Code{false}
\item \Code{label($g$)} returns an empty string; this ensures that it is always
  safe to use a label in an expression calling for a string
\item \Code{weight($g$)} throws an exception; there is no obvious default
  weight; a program can test for the presence/absence of a weight using the
  \Code{hasWeight($g$)} or \Code{hasNoWeight($g$)} methods
\end{itemize}

Of the attributes listed above, weight, label, color and position can be
accessed and modified by the user as well as the program.
Except in case of node positions, as noted above,
the user can do this only in edit mode.
In all cases of display attributes
modifications during runtime are ephemeral
-- the graph returns to its original, pre-execution, state after running the
animation.
The user can save the mid-execution state of the graph:
select the \Code{Export} option on the file menu of the
\emph{graph} window.

A final display attribute is visibility. An algorithm sometimes involves
deletion of nodes or edges, or, as is the case with our implementation of
Boruvka's algorithm, some edges are no longer important.
Graph elements can be hidden and made to reappear using the \Code{hide} and
\Code{show} functions.

To understand how showing and hiding of nodes and edges works, we need to
distinguish between the logical state of a node/edge and what is displayed.
Logically, for any graph element $g$, \Code{show($g$)} makes $g$ visible and
\Code{hide($g$)} makes it invisible.
For nodes, the logical and display state are the same -- a logically visible
node will be drawn on the graph window.
But an edge will be drawn only if it is logically visible \emph{and both of its
  endpoints are also logically visible.}

\input{Y_graph_element_functions}

A summary of functions relevant to node and edge attributes (their procedural versions)
is given in Table~\ref{tab:graph_element_functions}.
Some of the most important functions, those relevant to the structure of the
graph, are listed in Table~\ref{tab:graph_functions}.

\subsubsection{Global access for individual node/edge attributes and graph attributes}

\input{Y_graph_attribute_functions}

It is sometimes useful to access or manipulate attributes of nodes and edges
globally.
For example, an animation might want to hide node weights initially
and reveal them for individual nodes as
they become relevant.
Or it may want to hide edges individually as it progresses to get the effect
of deleting them and then reveal them again at the end.
These functionalities can be accomplished by
\Code{hideAllNodeWeights}\footnote{
  The modifier \Code{All} distinguishes
  \Code{show}/\Code{hide}\Code{All}\Code{Node}/\Code{Edge}\Code{Labels}/\Code{Weights}
  from
  \Code{show}/\Code{hide}\Code{Node}/\Code{Edge}\Code{Labels}/\Code{Weights}.
  The latter are designed to mimic user toggle buttons -- see Section~\ref{sec:declarations}.
}
or \Code{showEdges}, respectively.
A summary of these capabilities is given in Table~\ref{tab:graph_attribute_functions}.

\begin{itemize}
\item An algorithm hides some edges individually and uses \Code{showEdges} to
  make all of them visible in one step later.
\item An algorithm hides some nodes individually (along with their incident
  edges); it later makes all nodes visible and selectively makes some of
  their incident edges visible; nodes that were not hidden are unaffected;
  the visibility of any edges is not affected either.
\item An algorithm hides individual nodes and edges and later restores
  visibility to the whole graph; the function to use in this case is
  \Code{showGraph}.
\end{itemize}

\input{Y-declarations}

\subsubsection{Functions that behave as declarations} \label{sec:declarations}

Some Galant functions are independent of animation steps and are intended as
declarations at the beginning of the algorithm code.
These are listed in Table~\ref{tab:declarations}.
We already mentioned \Code{movesNodes()} -- it signals that the animation
will control node movement and prevents the user from moving nodes.

A second example is \Code{setDirected}. It has the same function as the
toggle buttons at the top of the graph window. In some cases, such as
shortest paths algorithms and breadth-first search, it makes sense for the
user to decide whether or not the animation should treat the graph as a
directed graph. Other animations, such as \Code{dfs\_d}, are specifically
designed for directed graphs. In those cases it makes sense for the animation
to make the graph directed. When \Code{setDirected} is called, the toggle
buttons (not visible during execution) are set as well, so that the state of
the buttons is consistent with that of the graph.

The remaining declarations involve visibility of weights and labels. As with
directedness, these functions mimic the actions of the appropriate toggle
buttons. The user may also change visibility of labels and weights during
execution. The declarations allow the animation to make visible exactly those
attributes that are relevant during its execution.
For example, the weighted graph algorithms (shortest paths and minimum
spanning trees) need the edge weights to be visible; a
\Code{showEdgeWeights()} call at the beginning ensures that this happens
regardless of whether the user made edge weights visible during editing (or
execution of a previous algorithm).

\subsection{Definition of Functions/Methods}\label{sec:functions}

A programmer can define arbitrary functions (methods) using the construct

\Code{function} \textsl{[return\_type]} \textsl{name} \Code{(}
 \textsl{parameters} \Code{) \{} \\
 \hspace*{3em} \emph{code block} \\
 \Code{\}}

The behavior is like that of a Java method. So, for example,
\begin{verbatim}
function int plus( int a, int b ) {
    return a + b;
}
\end{verbatim}
is equivalent to
\begin{verbatim}
static int plus( int a, int b ) {
    return a + b;
}
\end{verbatim}

The \textsl{return\_type} is optional. If it is missing, the function behaves like
a \Code{void} method in Java. An example is the recursive function
\Code{visit} in depth-first search.
\\
\Code{function visit( Node v ) \{} \textsl{code} \Code{\}}

\input{Y-data_structure_summary}

\input{Y_data_structures}

\subsection{Data Structures} \label{sec:datastructures}

Galant provides some standard data structures for nodes and edges.
These are described in detail in Tables~\ref{tab:data_structure_summary}
and~\ref{tab:data_structures}.
All Galant data structures are instances of the Java \Code{Collection}
interface and therefore automatically have the methods required of a
collection. For the interested Java programmer, they are also extensions of
relevant concrete Java classes and inherit those methods as well. For
details, see the Java source code in directory\\
\Code{src/edu/ncsu/csc/Galant/graph/datastructure}.

Galant provides procedural versions of the required methods \Code{size},
\Code{isEmpty}, \Code{add} and \Code{remove} for all structures, i.e., if $C$
is a collection (data structure) and $g$ is a graph element of the
appropriate type, the functions are \Code{size($C$)}, \Code{empty($C$)},
\Code{add($e$, $C$)} and \Code{remove($e$, $C$)}, respectively.

Table~\ref{tab:data_structure_summary} shows how each data structure can be
initialized in two different ways. One is to create a collection with no
elements, the other creates one from another collection that has the same
element type. For example, if \Code{S} is a previously declared and initialized
\Code{EdgeSet} (with elements added initially or later) you can say\\
\hspace*{1em}\Code{EdgeList L = new EdgeList(S)}\\
This becomes especially useful for priority queues -- see
Section~\ref{sec:sorting} and Table~\ref{tab:priority_queues} below for more
details on initializing and using these.
To create a priority queue containing all edges you would simply say\\
\hspace*{1em}\Code{EdgePriorityQueue PQ = new EdgePriorityQueue(getEdges())}

Java collections also have iterators. The syntax for accessing all elements
of a data structure is\\
\hspace*{1em}\Code{for ( \emph{type} $g$ : \emph{collection} ) \{ \emph{code
    body} \}}\\
where \emph{type} is either \Code{Node} or \Code{Edge}, $g$ is a variable,
and \emph{collection} is a data structure containing elements of the given
type. The code body is executed for each element in the collection,
referenced as $g$. For example, if \Code{S} is an \Code{EdgeSet} you could do

\begin{minipage}{\textwidth}
\begin{verbatim}
   for ( Edge e : S ) {
      highlight(e);
   }
\end{verbatim}
\end{minipage}

to highlight all the edge in \Code{S}.
The order of appearance of the elements depends on the structure.
For lists and queues it is the order in which they were added, for sets it is
random (the elements are hashed), and for priority queues it is based on the
values of the keys.

It is possible to create structures of type \Code{EdgeStack} and
\Code{NodeStack} but if you want simple procedural syntax and friendlier error reporting
we recommend using lists instead.

Table~\ref{tab:data_structures} summarizes the operations available on each
of the data structures.
The semantics of functions \Code{add}, \Code{remove}, \Code{size}, and
\Code{empty} are shown in the table only for lists, but apply to the others as well.

\subsection{Sorting, Priority Queues, and Comparators} \label{sec:sorting}

\input{Y-priority_queues}

Priority queues are a special case in that the order of appearance, which
affects the semantics of the key functions,
is dependent on the \emph{comparator} that is used to
determine their total order. Sorting also depends on a comparator, so we
discuss sorting and priority queues in the same section.
The default comparator for graph elements, nodes and edges, sorts them by
increasing weight. If $L$ is a list of nodes or edges\\
\hspace*{1em}\Code{sort($L$)}\\
rearranges the elements of $L$ so that they are in order of increasing weight
(if any element has no weight there is a null pointer exception). Galant \Code{sort} is
actually a Galant macro that expands to the Java \Code{Collections.sort}.
A comparator as second argument to \Code{sort} can alter the default
behavior. Galant makes available comparators that specify the attribute
(instead of weight) and the ordering (increasing or decreasing) as follows.
\begin{itemize}
  \item \Code{getDoubleComparator(String attribute)} returns a comparator
    based on the values of the given attribute, in increasing order;\\
    the default comparator is equivalent to \Code{getDoubleComparator("weight")}
  \item \Code{getDoubleComparator(String attribute, boolean reverse)} returns a comparator
    based on the values of the given attribute, in decreasing order if
    \Code{reverse} is \Code{true}, increasing if it is false;\\
    the default comparator is equivalent to \Code{getDoubleComparator("weight",
      false)}.
  \item \Code{getIntegerComparator(String attribute)} and
    \Code{getIntegerComparator(String attribute, boolean reverse)} behave
    like \Code{getDoubleComparator} except that the attribute has integer
    values;\\
    for example, \Code{getIntegerComparator("id", true)}
    sorts nodes (or edges) by decreasing \Code{id}.
  \item \Code{getStringComparator(String attribute)} and
    \Code{getStringComparator(String attribute, boolean reverse)} behave like
    their numerical counterparts; here the ordering is lexicographic;\\
    for example, \Code{getStringComparator("label", true)} sorts
    nodes or edges based on their labels, in decreasing lexicographic order
    ("zebra" comes before "antelope").
\end{itemize}
To do the sorting simply call \Code{sort} with the appropriate comparator as
second argument. For example, after
\begin{verbatim}
   EdgeList edges = getEdges();
   sort(edges, getStringComparator("label", true));
\end{verbatim}
the list \Code{edges} consists of all edges of the graph, sorted in
decreasing lexicographic order by their labels.

\textbf{Caution:} \emph{The type of the attribute must match the type of the
  comparator.}
The incantation \Code{getIntegerComparator("label")} does not work as
expected.
Because \Code{label} is not an integer attribute, the values being compared
will all be \Code{null} and any sort or priority queue operation based on the
comparator will result in a null pointer exception.

Table~\ref{tab:priority_queues} shows the procedural versions of priority
queue methods made available by Galant, along with the four ways to
initialize priority queues. Also listed are object-oriented methods that
yield additional functionality not yet implemented in procedural form.

If the priority queue is initialized from an existing data structure $C$ the
only option is for it to be a min-heap (the element that can be accessed and
removed efficiently is the one with smallest value) based on weight.
An empty queue can be initialized as a max-heap (using weight) or as a heap
that uses any valid comparator.
A \Code{GraphElementComparator} is a special case that stores both the
attribute used for comparison and whether the heap is to be min or max,
obtained using the \Code{get\emph{type}Comparator} functions described
earlier.
The additional information allows Galant to report errors if an element to be
added has a null value for the given attribute or if the animation program
attempts to \Code{removeMin} from a max-heap or vice-versa.

Priority queue functions are usually as efficient as expected.
A notable exception is \Code{changeKey}.
The operation \Code{changeKey($g$, $Q$)}
does \Code{remove($g$, $Q$)} followed by \Code{insert($g$, $Q$)}
and takes O($|Q|$) because of the \Code{remove}, which needs to search the
whole queue.

Unless you use object-oriented syntax you have to change the value of an
attribute before calling \Code{changeKey}. For example, you can do

\begin{minipage}{0.9\textwidth}
\begin{verbatim}
  NodePriorityQueue Q = new NodePriorityQueue();
  ...
  Node v = ...;
\end{verbatim}
\end{minipage}

and later

\begin{minipage}{0.4\textwidth}
\begin{verbatim}
  setWeight(v, 25);
  changeKey(v, Q);
\end{verbatim}
\end{minipage}
or
\begin{minipage}{0.4\textwidth}
\begin{verbatim}
  Q.changeKey(v, 25);
\end{verbatim}
\end{minipage}

\subsection{Queries}

An animation program can query the user for various kinds of input.
For example, the \Code{interactive\_dfs} algorithm asks the user to give a
starting node for a (directed) depth-first search and to give another start
node if the search terminates before all nodes are visited. The different
query options are listed in Table~\ref{tab:utility_functions}.

A query statement in an animation program initiates an algorithm step
unconditionally, i.e., even if it occurs within a
\Code{beginStep}-\Code{endStep} pair.
After the user responds to the query she has to do another step forward
before the animation proceeds (except in case of a Boolean query).
If the user steps backward after responding to a query, the query is not
invoked again. Subsequent forward steps use the same answer.
Thus it is not possible to allow a user to explore multiple alternative
executions in the same run (such a feature would require major enhancements
to the existing implementation).

Queries for nodes and edges ask for node id's (two of them in case of an
edge). Galant checks whether an id is that of a valid node and, in case of an
edge, whether an edge between the two nodes exists. If the graph is currently
directed, the direction of the edge also has to correspond. Any violation
causes an exception to be thrown -- a popup window reports the nature of the
error and allows the user to choose (a) different id(s).
The animator can impose additional restrictions by specifying a set of
permissible nodes/edges (unvisited nodes in the case of
\Code{interactive\_dfs}). If so, the animator also specifies an error message
in case the additional restriction is violated.

Other queries allow an animation to get strings, Boolean values, or numbers
from the user. Examples are in the \Code{binary\_tree} and \Code{grid}
algorithms which create complete binary trees or grid graphs based on tree
height or grid dimensions, respectively, specified as integers by the user.
These queries work the same way as those for vertices and edges. In case of
numbers Galant checks whether the input string is a valid integer or
floating point number and reports an error otherwise.

Boolean queries are a special case. The user does not type a response. The
only options are to press one of two buttons with the mouse or to press the
\Code{Enter} key to specify the default answer (true).
The animator can specify the text displayed on the buttons; defaults are
\Code{"yes"} and \Code{"no"}.
Another difference with Boolean queries is that the algorithm steps forward
immediately when the user responds to the query.\footnote{The reason this is
  not the case with other queries is that errors may need to be handled
  before the algorithm can proceed. Synchronization between the query and the
  algorithm is not straightforward.}

\subsection{Exceptions: Compile and Runtime Errors}

\input{Y-galant_exceptions}

Errors can occur at compile time, either because a macro is malformed or
because the Java code, after macro translation, has errors.
The reporting of Java compiler errors is straightforward. They are reported,
with line numbers, on the console. The line numbers correspond to those in
the Java code listing that also appears on the console (even if there are no
errors). In almost all cases the line numbers also correspond to those of the
original algorithm (before macro translation) in the text
window.\footnote{The only known exception is a function definition where the
  parameters are placed on multiple lines.}

Errors due to malformed macros are not, unfortunately, reported with line
numbers. To make matters worse, unbalanced parentheses or braces inside a
function definition or one of the \Code{for\_\ldots} macros result in a
malformed macro exception. The best strategy is to use a program editor that
does automatic indentation.

Runtime errors are also reported with (almost always correct) line
numbers. Galant makes every effort to catch errors before they result in, for
example, null pointer exceptions in the Galant implementation. Every function
with a graph element argument checks that the argument is not null and
reports a \Code{GalantException} if it is.
The second or third line in the stack trace
refers to the point in the algorithm where the exception occurred.
All exceptions, whether those caught as \Code{GalantException}'s with
meaningful messages or those caught in the Galant implementation code, result
in a stack trace on the console and a popup window.
The latter allows to user to choose whether to continue, meaning that the
algorithm is terminated and Galant returns to edit mode, or exit from Galant
completely.
Null pointer exceptions can almost always be tracked down by looking for the
first reference to the algorithm in the stack trace, an item of the form\\
\hspace*{4em}\Code{Galant.algorithm.code.compiled.\emph{algorithm\_name}.run(\emph{algorithm\_name}:\emph{line\_number})}

Exceptions can also occur in edit mode: when reading a graph from a
file, when specifying a node or edge after a keyboard shortcut, or when
giving the weight of a node or edge.
A list of the most common Galant exceptions is in Table~\ref{tab:galant_exceptions}.

% [Last modified: 2019 12 05 at 16:34:39 GMT]
